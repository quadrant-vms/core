# Quadrant VMS (Rust)

> âš™ï¸ A Video Management System (VMS) built in **Rust**.  
> The project aims to be **modular**, **cluster-ready**, and **AI-model friendly**.

---

## ðŸš§ Development Status
This project is **under active development**.

### âœ… Implemented
- `stream-node`: RTSP ingest â†’ HLS (TS/fMP4) with S3 upload fallback.
- `coordinator`: lease-based scheduler with REST API
  - **Persistent lease store** with PostgreSQL backend
  - In-memory backend option for development/testing
  - Configurable via `LEASE_STORE_TYPE` environment variable (`memory` or `postgres`)
  - Automatic database migrations with sqlx
  - Atomic lease operations with PostgreSQL transactions
  - Efficient lease expiration and cleanup
- `admin-gateway`: REST facade that acquires leases, launches `stream-node`, and stops streams via worker HTTP calls.
- `recorder-node`: Complete recording pipeline implementation with:
  - FFmpeg-based recording from RTSP and HLS sources
  - Multi-format output support (MP4, HLS, MKV)
  - Automatic metadata extraction (duration, resolution, codecs, bitrate, fps)
  - Recording job lifecycle management with REST API
  - Storage path tracking and S3 integration
  - **Coordinator lease integration** for distributed recording management
  - Automatic lease acquisition, renewal (50% TTL interval), and release
  - Lease failure detection with error state transitions
  - Configurable via `COORDINATOR_URL` and `NODE_ID` environment variables
- `admin-gateway`: Recorder worker management integration
  - REST API for recorder operations (`/v1/recordings`)
  - Lease-based recorder resource management via coordinator
  - Automatic lease acquisition and renewal for recordings
  - Recording lifecycle orchestration (start/stop/list)
  - Worker health monitoring and error handling
- **Failover hardening and resilience features**:
  - Worker health verification: admin-gateway checks worker liveness during lease renewal
  - Automatic retry with exponential backoff: lease renewals retry up to 3 times before marking stream as failed
  - Enhanced health endpoints: `/readyz` endpoint verifies lease store connectivity
  - Graceful degradation: temporary coordinator unavailability doesn't immediately kill active streams
  - Comprehensive error handling with detailed error messages and logging
- **Multi-coordinator clustering with leader election**:
  - Leader election using Raft-inspired consensus algorithm
  - Automatic failover and re-election on leader failure
  - Heartbeat-based health monitoring between coordinator nodes
  - Randomized election timeouts to prevent split votes
  - Cluster status API endpoint (`/cluster/status`)
  - Configurable via environment variables (`CLUSTER_ENABLED`, `NODE_ID`, `CLUSTER_PEERS`)
  - Support for single-node and multi-node cluster deployments
  - Integration tests validating leader election in 1-node and 3-node clusters
    - **Request forwarding from followers to leader**: Follower coordinators automatically forward write operations (acquire/renew/release) to the elected leader, enabling clients to connect to any coordinator node without tracking leader status
- **Advanced Metrics and Observability**:
  - Prometheus metrics integration across all services
  - Comprehensive metric collection for coordinators, stream-nodes, recorder-nodes, admin-gateway, and ai-service
  - `/metrics` endpoint on all services for Prometheus scraping
  - Coordinator metrics: active leases, lease operations, cluster nodes, leader elections, forwarded requests
  - Stream-node metrics: active streams, HLS segments, S3 uploads, bytes processed
  - Recorder-node metrics: active recordings, recording operations, bytes recorded, completion status
  - Admin-gateway metrics: HTTP requests, request duration, active workers, worker operations
  - AI-service metrics: active tasks, frames processed, detections made, detection latency, plugin health
  - Centralized metrics registry in telemetry crate
- **AI Model Plugin Architecture**:
  - `ai-service`: Modular AI plugin system with extensible architecture
  - Plugin trait interface for custom AI model integrations
  - Plugin registry with dynamic plugin registration and management
  - Built-in mock object detection plugin for testing and demonstration
  - **YOLOv8 object detection plugin**:
    - Real-time object detection using YOLOv8 ONNX models
    - Support for all YOLOv8 model variants (nano, small, medium, large, extra-large)
    - CPU and GPU inference support via ONNX Runtime
    - Non-Maximum Suppression (NMS) for overlapping box filtering
    - Configurable confidence and IoU thresholds
    - 80 COCO classes detection (person, car, dog, etc.)
    - Automatic scaling to original image dimensions
    - Environment variable configuration (`YOLOV8_MODEL_PATH`, `YOLOV8_CONFIDENCE`)
  - **Frame capture pipeline**:
    - FFmpeg-based frame extraction utilities in common crate
    - REST API endpoint for frame submission (`POST /v1/tasks/:id/frames`)
    - Real-time frame processing with AI plugins
    - Base64-encoded JPEG frame transport for JSON compatibility
    - Automatic frame dimension probing with ffprobe
    - Configurable JPEG quality and scaling
    - Frame sequence tracking and timestamp management
    - **Stream-node integration** with periodic frame capture for live AI processing
    - Configurable capture intervals, resolution, and quality settings
    - Automatic frame submission to AI service with task management
    - CancellationToken-based lifecycle management for clean shutdown
  - REST API for AI task lifecycle management (`/v1/tasks`)
  - Coordinator lease integration for distributed AI task management
  - Automatic lease acquisition, renewal, and release for AI tasks
  - Support for multiple output formats (webhook, MQTT, RabbitMQ, local file)
  - Frame-based processing with configurable sampling rates
  - Comprehensive metrics for AI operations (tasks, frames, detections, latency)
  - Health check endpoints for plugin monitoring
  - Configurable via `AI_SERVICE_ADDR`, `COORDINATOR_URL`, and `NODE_ID` environment variables
  - Standalone or coordinator-integrated deployment modes
- **Recorder-node AI integration**:
  - Frame capture from active recordings for AI processing
  - Optional AI configuration per recording (RecordingAiConfig)
  - Automatic frame extraction and submission to AI service
  - Configurable capture interval, resolution, and quality
  - Integration with ai-service via REST API
  - Backward compatible (AI processing is optional)
  - Clean lifecycle management with cancellation tokens
- **Comprehensive Test Suite** (`cargo test`):
  - Unit tests for lease store logic, router contracts, recording lifecycle, pipeline configuration
  - Integration tests for recorder-coordinator integration, cluster leader election, metrics collection
  - AI plugin system tests, frame capture pipeline tests, recorder AI integration tests
  - **Full end-to-end integration tests** (`tests/full_pipeline_e2e.rs`):
    - Complete pipeline: stream â†’ recording â†’ AI processing with coordinator orchestration
    - Multi-service interaction: admin-gateway â†” coordinator â†” stream-node â†” recorder-node â†” ai-service
    - Lease management across all service types (stream, recorder, AI tasks)
    - Health check verification across all services
    - Multi-component error handling and recovery scenarios
  - 38 total tests validating the entire VMS stack

- **GPU Acceleration Optimization**:
  - CUDA and TensorRT execution provider support for YOLOv8
  - Automatic fallback from TensorRT â†’ CUDA â†’ CPU
  - Multi-GPU support with device selection
  - Configurable thread pools (intra/inter-operation parallelism)
  - GPU memory limit configuration
  - Performance monitoring with execution provider tracking
  - Comprehensive metrics for GPU vs CPU inference comparison
  - Environment variable and JSON configuration support
  - Detailed GPU setup documentation in `docs/GPU_ACCELERATION.md`
  - Inference time tracking separate from pre/post-processing

- **Stateless Architecture & High Availability** (`ENABLE_STATE_STORE=true`):
  - **StateStore HTTP API** in coordinator for persisting stream/recording/AI task state
  - **PostgreSQL-backed** persistent state storage via StateStore trait
  - **HTTP client** (StateStoreClient) in common crate for remote state access
  - **Admin-gateway integration**: automatic state persistence on all state changes
  - **Worker nodes integration**: recorder-node and ai-service persist state during lifecycle
  - **Bootstrap logic**: restore state from StateStore on startup for all services
  - **Automated orphan cleanup**: detect and automatically remove orphaned resources
    - Cleanup runs on startup and periodically (configurable via `ORPHAN_CLEANUP_INTERVAL_SECS`)
    - Default interval: 300 seconds (5 minutes)
    - Removes orphaned streams/recordings (non-active state with stale leases)
    - In-memory and persistent state cleanup
  - **Multi-instance coordination** for active-active HA deployments:
    - StateStore shared across multiple coordinator instances via PostgreSQL
    - Worker nodes connect to any coordinator for state operations
    - Automatic state synchronization across cluster
    - Supports distributed worker nodes across multiple admin-gateway instances
    - Complete HA deployment guide in `docs/HA_DEPLOYMENT.md`
  - **State migration tools** (`state-migrate` binary):
    - `check` - Verify database schema and migrations
    - `list-orphans` - List orphaned resources with filtering
    - `cleanup-orphans` - Clean up orphans (with dry-run mode)
    - `export` - Export all state to JSON for backup/migration
    - `import` - Import state from JSON (with skip-existing option)
    - `vacuum` - Database maintenance (VACUUM ANALYZE)
    - `stats` - Show comprehensive state store statistics
  - **Comprehensive integration tests** (`tests/stateless_integration.rs`):
    - StateStore save/retrieve/update operations
    - List by node_id filtering
    - Orphan detection logic validation
    - HTTP API endpoint testing
    - State persistence across restarts
    - Bootstrap recovery scenarios
  - **State persistence** across lease renewals, errors, and health check failures
  - **Backward compatible**: works with or without StateStore enabled
  - **Environment variables**:
    - `ENABLE_STATE_STORE=true` to enable state persistence
    - `ORPHAN_CLEANUP_INTERVAL_SECS=300` for cleanup interval (default: 5 minutes)

- **Authentication & Authorization System**:
  - `auth-service`: Centralized authentication service
    - **User management**: Create, read, update, delete users
    - **JWT-based authentication**: Secure token-based API access
    - **API tokens**: Long-lived tokens for service-to-service authentication
    - **Role-Based Access Control (RBAC)**: Fine-grained permission system
    - **Multi-tenancy support**: Isolated tenant environments with resource quotas
    - **Audit logging**: Complete security audit trail for compliance
    - **PostgreSQL-backed storage**: Users, roles, permissions, tenants, tokens, audit logs
    - **OIDC/OAuth2 SSO Integration**: Single Sign-On with external identity providers
      - Google Workspace / Google Identity support
      - Microsoft Azure AD / Entra ID support
      - Keycloak support
      - Generic custom OIDC provider support
      - Automatic user provisioning on first SSO login
      - OIDC identity linking and management
      - CSRF-protected authorization flow
  - **auth_middleware** (common crate): Shared authentication middleware
    - JWT token verification and validation
    - Permission checking utilities
    - Request context injection
    - Support for both JWT and API token authentication
  - **Comprehensive permission system**:
    - Resource-based permissions (stream, recording, ai_task, device, user, role, tenant, audit)
    - Action-based controls (read, create, update, delete)
    - Built-in roles: System Administrator, Operator, Viewer
    - Custom role creation and management
    - Permission inheritance through roles
    - System admin bypass for all permission checks
  - **Tenant isolation**:
    - Separate users and roles per tenant
    - Resource quotas (max_users, max_streams, max_recordings, max_ai_tasks)
    - Tenant-scoped audit logs
    - Cross-tenant access only for system admins
  - **Security features**:
    - Argon2 password hashing
    - Secure API token generation (cryptographically random)
    - Token expiration and revocation
    - Configurable JWT expiration (default: 1 hour)
    - Last login tracking
    - Audit log with IP address and user agent tracking
  - **Default system setup**:
    - System tenant pre-configured
    - Default admin user (username: admin, password: admin123 - CHANGE IN PRODUCTION!)
    - Built-in roles: system-admin, operator, viewer
    - 29 default permissions covering all resources (including device management)
  - **Integration tests** (`tests/auth_integration.rs`):
    - JWT generation and verification
    - Password hashing and validation
    - API token lifecycle
    - Permission checking logic
    - System admin privilege escalation
  - **Complete documentation** in `docs/AUTHENTICATION.md`
  - **REST API** for all auth operations
  - **Environment variables**:
    - `DATABASE_URL` - PostgreSQL connection string
    - `JWT_SECRET` - Secret key for JWT signing (CHANGE IN PRODUCTION!)
    - `JWT_EXPIRATION_SECS` - Token expiration time (default: 3600)
    - `AUTH_SERVICE_ADDR` - Bind address (default: 127.0.0.1:8083)

- **Device & Topology Management**:
  - `device-manager`: Comprehensive camera and device management system
    - **Device onboarding and registration**: Add cameras, NVRs, encoders to the system
    - **RTSP device probing**: Automatic capability detection using ffprobe
      - Video codec detection (H.264, H.265, MJPEG, etc.)
      - Audio codec detection
      - Resolution discovery
      - Metadata extraction (manufacturer, model)
    - **Multi-protocol support**: RTSP, ONVIF, HTTP, RTMP, WebRTC
    - **Device categorization**: Types (camera, NVR, encoder, other), zones, tags
    - **Health monitoring system**:
      - Automated periodic health checks
      - Configurable check intervals per device
      - Status tracking (online, offline, error, maintenance, provisioning)
      - Health history with timestamps and response times
      - Consecutive failure tracking
      - Automatic status transitions based on health check results
    - **Batch operations**: Update multiple devices simultaneously
    - **PostgreSQL-backed storage**: Persistent device state, health history, events
    - **Device event audit trail**: Tracks all device state changes and operations
    - **Secure credential management**: Encrypted storage of device passwords
    - **Rich device metadata**:
      - Manufacturer, model, firmware version
      - Location and zone assignment
      - Custom tags for organization
      - Device capabilities (PTZ, audio, motion detection)
      - Supported codecs and resolutions
      - Auto-start, recording, and AI enablement flags
    - **REST API** for all device operations:
      - CRUD operations for devices
      - Device health status and history endpoints
      - On-demand device probing
      - Batch update endpoint
    - **Integration with auth-service**:
      - Tenant-isolated device management
      - Permission-based access control (device:read, device:create, device:update, device:delete)
      - Operator role includes device management permissions
    - **Integration tests** (`tests/device_manager_integration.rs`):
      - Device CRUD operations
      - Health tracking and history
      - Store operations validation
    - **Environment variables**:
      - `DATABASE_URL` - PostgreSQL connection string
      - `DEVICE_MANAGER_ADDR` - Bind address (default: 127.0.0.1:8084)
      - `PROBE_TIMEOUT_SECS` - Device probe timeout (default: 10)
      - `HEALTH_CHECK_INTERVAL_SECS` - Global health check interval (default: 30)
      - `MAX_CONSECUTIVE_FAILURES` - Failures before marking as error (default: 3)

### ðŸ”œ In Progress

#### Upcoming Features
- **PTZ & advanced device control**: PTZ commands, camera configuration push, firmware update management
- **Playback & delivery**: LL-HLS/WebRTC/RTSP proxy, thumbnails/time-axis preview, DVR time-shift & seek, edge caching
- **Storage & retention**: lifecycle/retention policies, tiered/cold storage, integrity checks, resumable/retry uploads with catalog/index
- **Search & evidencing**: recording/event index, object/time-range search, signed snapshots/exports, chain-of-custody metadata
- **Alerts & automation**: rule engine, multi-channel notifications (Email/SMS/Webhook/MQTT), suppression/severity, scheduling
- **Observability**: centralized structured logs, tracing across services, SLO dashboards and alerts by tenant/node
- **Operator UI**: dashboards for devices/streams/recordings/AI tasks, incident workflows
- **Additional AI model integrations**: pose estimation, facial recognition

---

## ðŸ’¡ Follow Progress
Each milestone (camera compatibility, failover tests, AI plugin, etc.)
will unlock sequentially as community funding goals are reached.

Stay tuned.

---
Â© 2025 Quadrant Intelligence Studio
